/**
 * This ruleset defines the security model for the "Whisper Rooms" application.
 *
 * Core Philosophy:
 * The security model is built on two primary patterns: strict user-ownership for private
 * data and creator-ownership for publicly readable data. This ensures a clear separation
 * between personal user information and shared application content. The default posture
 * is to deny all access unless explicitly granted.
 *
 * Data Structure:
 * The Firestore database is organized into several top-level collections:
 * - /users/{userId}: Stores private UserProfile documents.
 * - /rooms/{roomId}: Stores public Room documents.
 * - /privateChats/{chatId}: Stores private conversation metadata.
 *
 * Key Security Decisions:
 * - User Privacy: Listing users from the top-level /users collection is explicitly
 *   disallowed to prevent user enumeration and protect privacy.
 * - Public Discoverability: The /rooms collection is publicly readable to allow
 *   users to browse and discover available voice chat rooms.
 * - Creator Control: Write access to a room is restricted to its creator.
 * - Chat Participation: Any authenticated user can read/write messages in a public room.
 * - Private Chat Security: Private chats and their messages are only accessible to
 *   the participants of that chat.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //-------------------------------------------------------------------------
    // Helper Functions
    //-------------------------------------------------------------------------

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    function hasValidUserProfileDataForCreate(userId) {
      let data = request.resource.data;
      return data.id == userId;
    }

    function hasValidUserProfileDataForUpdate() {
      let data = request.resource.data;
      return data.id == resource.data.id;
    }

    function hasValidRoomDataForCreate(roomId) {
      let data = request.resource.data;
      return data.creatorId == request.auth.uid
          && data.id == roomId;
    }

    function hasValidRoomDataForUpdate() {
      let data = request.resource.data;
      return data.creatorId == resource.data.creatorId
          && data.id == resource.data.id;
    }
    
    function hasValidChatMessageDataForCreate(messageId) {
        let data = request.resource.data;
        return data.id == messageId
            && data.senderId == request.auth.uid
            && data.text is string
            && data.text.size() > 0 && data.text.size() <= 280
            && data.createdAt == request.time;
    }
    
    function isParticipant(chatId) {
        return isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/privateChats/$(chatId)).data.participantIds;
    }
    
    function hasValidPrivateMessageDataForCreate(messageId) {
        let data = request.resource.data;
        return data.id == messageId
            && data.senderId == request.auth.uid
            && data.text is string
            && data.text.size() > 0
            && data.createdAt == request.time;
    }

    //-------------------------------------------------------------------------
    // Collection Rules
    //-------------------------------------------------------------------------

    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && hasValidUserProfileDataForCreate(userId);
      allow update: if isExistingOwner(userId) && hasValidUserProfileDataForUpdate();
      allow delete: if isExistingOwner(userId);
    }

    match /rooms/{roomId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && hasValidRoomDataForCreate(roomId);
      allow update: if isExistingOwner(resource.data.creatorId) && hasValidRoomDataForUpdate();
      allow delete: if isExistingOwner(resource.data.creatorId);

      match /messages/{messageId} {
        allow list, get: if isSignedIn();
        allow create: if isSignedIn() && hasValidChatMessageDataForCreate(messageId);
        allow update, delete: if false;
      }
    }
    
    match /privateChats/{chatId} {
        allow get, list: if isParticipant(chatId);
        allow create: if isSignedIn() && request.auth.uid in request.resource.data.participantIds;
        allow update: if isParticipant(chatId); // For updating lastMessage
        allow delete: if false;
        
        match /messages/{messageId} {
            allow list, get: if isParticipant(chatId);
            allow create: if isParticipant(chatId) && hasValidPrivateMessageDataForCreate(messageId);
            allow update, delete: if false;
        }
    }
  }
}
